variable "svc_name" {
    description = "Service name"
    type = string
}

variable "purpose" {
    description = "VPC purpose"
    type = string
}

variable "env" {
    description = "Stage (dev, stg, prod etc)"
    type = string
}

variable "region_name_alias" {
    description = "AWS VPC region name alias like KR"
    type = string
}

variable "elbs" {
    description = "ALB/NLB configuration variable"
    type = map(any)
    /* key => elb name #(Optional) The name of the ELB. By default generated by Terraform.
    type = map(object({
        type = string #(Optional) The type of load balancer to create. Possible values are application, gateway, or network
        internal = bool #(Optional) If true, the LB will be internal
        security_groups = list(string) #(ALB, Optional) A list of security group IDs to assign to the LB
        subnets = list(string) #(ALB, Optional) A list of subnet IDs to attach to the LB
        subnet_mapping = list(object({ #(NLB, Optional) A subnet mapping block
            subnet_id = string #(Required) ELB mapping subnet id
            create_eip = bool #(Optional) Allocate Elastic IP address 
            availability_zone = string #(Required if create_eip is true)
            allocation_id = string #(Optional) The allocation ID of the Elastic IP address.
            private_ipv4_address = string #(Optional) A private ipv4 address within the subnet to assign to the internal-facing load balancer.
            ipv6_address = string #(Optional) An ipv6 address within the subnet to assign to the internet-facing load balancer.
        }))
        ip_address_type = string #(Optional) The type of IP addresses used by the subnets for your load balancer(ipv4/dualstack)
        drop_invalid_header_fields = bool #(Optional) Indicates whether HTTP headers with header fields that are not valid are removed by the load balancer(true) or routed to targets(false)(default: false)
        access_logs = object({ #(Optional) An Access Logs block
            bucket = string # access logging bucket name
            prefix = string # bucket prefix
            enabled = bool # enable/disable access logging
        })
        idle_timeout = number #(ALB, Optional) The time in seconds that the connection is allowed to be idle (default: 60)
        enable_deletion_protection = bool #(Optional) If true, deletion of the load balancer will be disabled via the AWS API (default: false)
        enable_cross_zone_load_balancing = bool # (NLB, Optional) If true, cross-zone load balancing of the load balancer will be enabled. (default: false)
        enable_http2 = bool #(ALB, Optional) Indicates whether HTTP/2 is enabled (default: true)
        enable_waf_fail_open = bool #(Optional) WAF로 보낼 수 없는 트래픽을 ELB로 보낼지 여부 (default: false)
        customer_owned_ipv4_pool = string # (Optional) The ID of the customer owned ipv4 pool to use for this load balancer.
        desync_mitigation_mode = string # (Optional) Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync (monitor,defensive(default),strictest)
        
        listeners = list(object({
            port = number #(Optional) Port on which the load balancer is listening (Not valid for Gateway Load Balancers)
            protocol = string #(Optional) Protocol for connections from clients to the load balancer (ALB: HTTP(default),HTTPS, NLB: TCP,TLS,UDP,TCP_UDP)
            ssl_policy = string #(Optional) Name of the SSL Policy for the listener
            certificate_arn = string #(Optional) ARN of the default SSL server certificate
            additional_certificate_arns = list(string) #(Optional) ARN of the default SSL server certificate
            alpn_policy = string #(Optional) Name of the Application-Layer Protocol Negotiation(ALPN) policy HTTP1Only, HTTP2Only, HTTP2Optional, HTTP2Preferred, and None
            
            default_action = object({ #(Required) Configuration block for default actions
                type = string #(Required) Type of routing action (forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc)
                order = number #(Optional) Order for the action. This value is required for rules with multiple actions between 1 and 50000
                target_group_name = string #(forward, Optional) Name of the Target Group to which to route traffic. Specify
                authenticate_cognito = object({ #(Optional) Configuration block for using Amazon Cognito to authenticate users
                    user_pool_arn = string #(Required) ARN of the Cognito user pool.
                    user_pool_client_id = string #(Required) ID of the Cognito user pool client.
                    user_pool_domain = string #(Required) Domain prefix or fully-qualified domain name of the Cognito user pool.
                    authentication_request_extra_params = map(string)
                    on_unauthenticated_request = string #(Optional) Behavior if the user is not authenticated (deny, allow, authenticate)
                    scope = string #(Optional) Set of user claims to be requested from the IdP.
                    session_cookie_name = string #(Optional) Name of the cookie used to maintain session information.
                    session_timeout = number # (Optional) Maximum duration of the authentication session, in seconds.
                })
                authenticate_oidc = object({ #(Optional) Configuration block for an identity provider that is compliant with OpenID Connect (OIDC).
                    authorization_endpoint = string #(Required) Authorization endpoint of the IdP
                    client_id = string #(Required) OAuth 2.0 client identifier.
                    client_secret = string #(Required) OAuth 2.0 client secret.
                    issuer = string #(Required) OIDC issuer identifier of the IdP.
                    token_endpoint = string #(Required) Token endpoint of the IdP.
                    user_info_endpoint = string #(Required) User info endpoint of the IdP.
                    authentication_request_extra_params = map(string) #(Optional) Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
                    on_unauthenticated_request = string #(Optional) Behavior if the user is not authenticated. Valid values: deny, allow and authenticate
                    scope = string #(Optional) Set of user claims to be requested from the IdP.
                    session_cookie_name = string #(Optional) Name of the cookie used to maintain session information.
                    session_timeout = string #(Optional) Maximum duration of the authentication session, in seconds.
                })
                fixed_response = object({ #(Optional) Information for creating an action that returns a custom HTTP response
                    content_type = string #(Required) Content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
                    message_body = string #(Optional) Message body.
                    status_code = string #(Optional) HTTP response code. Valid values are 2XX, 4XX, or 5XX.
                })
                weighted_forward = object({ #(Optional) Configuration block for creating an action that distributes requests among one or more target groups
                    target_groups = list(object({ #(Required) Set of 1-5 target group blocks
                        name = string #(Required) Name of the target group.
                        weight = number #(Optional) Weight. The range is 0 to 999.
                    }))
                    stickiness = object({
                        duration = number #(Required) Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
                        enabled = bool #(Optional) Whether target group stickiness is enabled. (default: false)
                    })
                })
                redirect = object({ #(Optional) Configuration block for creating a redirect action.
                    status_code = string #(Required) HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
                    host = string #(Optional) Hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
                    path = string #(Optional) Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
                    port = number #(Optional) Port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
                    protocol = string #(Optional) Protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
                    query = string #(Optional) Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
                })
            }) // End of default_action
            
            rules = list(object({
                priority = number #(Optional) The priority for the rule between 1 and 50000
                actions = list(object({
                    type = string #(Required) Type of routing action (forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc)
                    target_group_name = string #(forward, Optional) The Name of the Target Group to which to route traffic 
                    weighted_forward = object({ #(Optional) Configuration block for creating an action that distributes requests among one or more target groups
                        target_groups = list(object({ #(Required) Set of 1-5 target group blocks
                            name = string #(Required) Name of the target group.
                            weight = number #(Optional) Weight. The range is 0 to 999.
                        }))
                        stickiness = object({
                            duration = number #(Required) Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
                            enabled = bool #(Optional) Whether target group stickiness is enabled. (default: false)
                        })
                    })
                    redirect = object({ #(Optional) Configuration block for creating a redirect action.
                        status_code = string #(Required) HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
                        host = string #(Optional) Hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
                        path = string #(Optional) Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
                        port = number #(Optional) Port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
                        protocol = string #(Optional) Protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
                        query = string #(Optional) Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
                    })
                    fixed_response = object({ #(Optional) Information for creating an action that returns a custom HTTP response
                        content_type = string #(Required) Content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
                        message_body = string #(Optional) Message body.
                        status_code = string #(Optional) HTTP response code. Valid values are 2XX, 4XX, or 5XX.
                    })
                    authenticate_cognito = object({ #(Optional) Configuration block for using Amazon Cognito to authenticate users
                        user_pool_arn = string #(Required) ARN of the Cognito user pool.
                        user_pool_client_id = string #(Required) ID of the Cognito user pool client.
                        user_pool_domain = string #(Required) Domain prefix or fully-qualified domain name of the Cognito user pool.
                        authentication_request_extra_params = map(string)
                        on_unauthenticated_request = string #(Optional) Behavior if the user is not authenticated (deny, allow, authenticate)
                        scope = string #(Optional) Set of user claims to be requested from the IdP.
                        session_cookie_name = string #(Optional) Name of the cookie used to maintain session information.
                        session_timeout = number # (Optional) Maximum duration of the authentication session, in seconds.
                    })
                    authenticate_oidc = object({ #(Optional) Configuration block for an identity provider that is compliant with OpenID Connect (OIDC).
                        authorization_endpoint = string #(Required) Authorization endpoint of the IdP
                        client_id = string #(Required) OAuth 2.0 client identifier.
                        client_secret = string #(Required) OAuth 2.0 client secret.
                        issuer = string #(Required) OIDC issuer identifier of the IdP.
                        token_endpoint = string #(Required) Token endpoint of the IdP.
                        user_info_endpoint = string #(Required) User info endpoint of the IdP.
                        authentication_request_extra_params = map(string) #(Optional) Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
                        on_unauthenticated_request = string #(Optional) Behavior if the user is not authenticated. Valid values: deny, allow and authenticate
                        scope = string #(Optional) Set of user claims to be requested from the IdP.
                        session_cookie_name = string #(Optional) Name of the cookie used to maintain session information.
                        session_timeout = string #(Optional) Maximum duration of the authentication session, in seconds.
                    })
                })) // End of actions
                conditions = list(object({
                    host_headers = list(string) #(Optional) Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters.
                    http_headers = list(object({ #(Optional) HTTP headers to match
                        http_header_name = string
                        values = list(string)
                    }))
                    http_request_methods = list(string) #(Optional) Contains a single values item which is a list of HTTP request methods or verbs to match
                    path_patterns = list(string) #(Optional) Contains a single values item which is a list of path patterns to match against the request URL
                    query_strings = list(object({ #(Optional) Query strings to match
                        key = string #(Optional) Query string key pattern to match.
                        value = string #(Required) Query string value pattern to match.
                    }))
                    source_ips = list(string) #(Optional) Contains a single values item which is a list of source IP CIDR notations to match
                }))
            })) // End of conditions
            tags = map(string)
        })) // End of rules
        tags = map(string)
    }))
    */
    default = {}
}

variable "target_groups" {
    description = "target group configuration for alb"
    type = any
    /* key => target group name #(Optional, Forces new resource) Name of the target group. If omitted, Terraform will assign a random, unique name.
    type = map(object({
        target_type = string #(Required) Type of target that you must specify when registering targets with this target group (intance, ip, alb, lambda default: instance)
        vpc_id = string #(Optional) Identifier of the VPC in which to create the target group
        port = number #(May be required, Forces new resource) Port on which targets receive traffic, (for instance, ip or alb not for lambda)
        protocol = string # (May be required, Forces new resource) GENEVE, HTTP, HTTPS, TCP, TCP_UDP, TLS, or UDP not for lambda
        protocol_version = string # (Optional, Forces new resource) Only applicable when protocol is HTTP or HTTPS (default: HTTP1)
        proxy_protocol_v2 = bool #(Optional) Whether to enable support for proxy protocol v2 on Network Load Balancers (default: false, for nlb)
        preserve_client_ip = bool #(Optional) Whether client IP preservation is enabled.
        load_balancing_algorithm_type = string #round_robin or least_outstanding_requests (default: round_robin)
        targets = list(object({ #(Optional) targets to attach target_group
            target_id = string #(Required) The ID of the target. This is the Instance ID for an instance, or the container ID for an ECS container
                               # If the target type is ip, specify an IP address. If the target type is lambda, specify the arn of lambda. If the target type is alb, specify the arn of alb
            port = number #(Optional) The port on which targets receive traffic.
            availability_zone = string #(Optional) The Availability Zone where the IP address of the target is to be registered.
        }))
        health_check = object({
            enabled = bool # (Optional) Whether health checks are enabled. (default: true)
            healthy_threshold = number #(Optional) Approximate amount of time, in seconds, between health checks of an individual target. (default: 30)
            matcher = string #(May be required) Response codes to use when checking for a healthy responses from a target
            path = string #(May be required) Destination for the health check request
            port = number #(Optional) Port to use to connect with the target. 
            protocol = string #(Optional) Protocol to use to connect with the target (default: HTTP, N/A when target_type is lambda)
            timeout = number #(Optional) Amount of time, in seconds, during which no response means a failed health check (default: 10)
            unhealthy_threshold = number #(Optional) Number of consecutive health check failures required before considering the target unhealthy. (default: 3)
        })
        slow_start = string #(Optional) Amount time for targets to warm up before the load balancer sends them a full share of requests (default: 0 - disabled)
        deregistration_delay = number # (Optional) Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused (default: 300)
        connection_termination = bool #(NLB, Optional) Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. (default: false)
        stickiness = object({
            enabled = bool #(Optional) Boolean to enable / disable stickiness.(default: true)
            type = string #(Required) The type of sticky sessions. The only current possible values are lb_cookie, app_cookie for ALBs, and source_ip for NLBs.
            cookie_duration = number #(Optional) Only used when the type is lb_cookie (default:86400(1day))
            cookie_name = string #(Optional) Name of the application based cookie.
        })
        lambda_multi_value_headers_enabled = bool #(Lambda, Optional) Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings (default: false)
        tags = map(string) #(Optional) resource tags
    }))
    */
    default = {}
}